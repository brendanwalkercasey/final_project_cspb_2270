#include <tiffio.h>
#include <iostream>
#include <vector>
#include <cstdint>  // For fixed-width integers
#include <cmath>
#include <algorithm> // For std::min, std::max
#define u32 std::uint32_t
#define u16 std::uint16_t
#define u8 std::uint8_t
using namespace std;

/*
Key changes from v06:
The issue where both the compressed and decompressed images appear all black is likely due to the way the wavelet transform is applied and how the image data is handled. Let's break down potential causes and solutions.

1. Wavelet Transformation Scaling
The main issue could be related to the values generated by the wavelet transform. The mexicanHatWavelet function generates floating-point values (both negative and positive) and is then cast back to u8 values, which can cause clipping to 0 if the transformed values are outside the range [0, 255]. This could explain why the image appears all black.

Solution:
Scaling the values: After applying the wavelet transform, ensure that the values are scaled properly back to the valid range of [0, 255] for 8-bit grayscale images.
Clamping values: In your current code, you're directly casting the result of the mexicanHatWavelet transform to u8, but this can result in values being clamped to 0 if they are outside the [0, 255] range. You should instead normalize or scale the values properly.
2. Use of the mexicanHatWavelet Function
The mexicanHatWavelet function can produce negative values, which are problematic for image representation (since images use positive values, typically in the range of 0 to 255). To address this, you need to:

Apply an offset to ensure all values are positive.
Normalize the values after applying the transform.
Modifications:
You need to update how the mexicanHatWavelet values are handled in both the compression (wavelet) and decompression (inverse transform) steps. Here's an updated approach:

Step 1: Normalize the Output of the Mexican Hat Wavelet
Ensure that the values from the wavelet transformation are scaled to fit the valid pixel range [0, 255].

Step 2: Scale and Normalize During the Inverse Transformation
When performing the inverse transform, make sure that the values are in a reasonable range before writing them to a TIFF file.
*/

// Function to read a TIFF image
void readTiffImage(const char* filename, vector<u8>& buffer, u32& width, u32& height, u16& samples_per_pixel) {      
    TIFF* tiff = TIFFOpen(filename, "r");
    if (tiff == nullptr) {
        cerr << "Could not open TIFF file!" << endl;
        return;
    }

    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);
    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);
    TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel);

    buffer.resize(width * height * samples_per_pixel);
    for (u32 row = 0; row < height; row++) {
        TIFFReadScanline(tiff, &buffer[row * width * samples_per_pixel], row);
    }

    TIFFClose(tiff);
}

// Function to compute the Mexican Hat (Ricker) wavelet at a point x
double mexicanHatWavelet(double x, double sigma) {
    return (1 - (x * x) / (sigma * sigma)) * exp(-x * x / (2 * sigma * sigma));
}

// Function to apply wavelet compression (simplified)
void waveletTransform(vector<u8>& buffer, u32 width, u32 height) {
    double min_value = std::numeric_limits<double>::max();
    double max_value = std::numeric_limits<double>::lowest();

    // Apply a simple Mexican Hat wavelet transform (this is for compression simulation)
    for (u32 row = 0; row < height; row++) {
        for (u32 col = 0; col < width; col++) {
            // Apply wavelet to each pixel (normalize output range)
            double transformed = mexicanHatWavelet(buffer[row * width + col], 10.0);
            min_value = std::min(min_value, transformed);
            max_value = std::max(max_value, transformed);
            buffer[row * width + col] = static_cast<u8>(transformed);
        }
    }

    // Normalize the values to fit within the 0-255 range for 8-bit grayscale
    for (u32 row = 0; row < height; row++) {
        for (u32 col = 0; col < width; col++) {
            double normalized = (buffer[row * width + col] - min_value) / (max_value - min_value) * 255.0;
            buffer[row * width + col] = static_cast<u8>(std::clamp(normalized, 0.0, 255.0));
        }
    }
}

// Function to apply inverse Mexican Hat wavelet transform (decompression)
void inverseMexicanHatTransform(vector<double>& data, size_t width, size_t height, double sigma) {
    vector<double> result(data.size(), 0);
    int kernel_size = 7; // Example kernel size
    int offset = kernel_size / 2; // Kernel center

    for (size_t i = 0; i < height; ++i) {
        for (size_t j = 0; j < width; ++j) {
            double sum = 0;
            for (int m = -offset; m <= offset; ++m) {
                for (int n = -offset; n <= offset; ++n) {
                    int x = j + n;
                    int y = i + m;
                    if (x >= 0 && x < width && y >= 0 && y < height) {
                        double kernel_value = mexicanHatWavelet(sqrt(m * m + n * n), sigma);
                        sum += data[y * width + x] * kernel_value;
                    }
                }
            }
            result[i * width + j] = sum;
        }
    }
    data = std::move(result); // Update the data with the decompressed result
}

// Function to convert double values to u8 (clamp to valid range)
void convertToUint8(const vector<double>& input, vector<u8>& output, size_t width, size_t height) {
    output.resize(width * height);
    for (size_t i = 0; i < width * height; ++i) {
        output[i] = static_cast<u8>(std::min(255.0, std::max(0.0, input[i])));
    }
}

// Function to write a TIFF image from the buffer
void writeTiffImage(const char* filename, const vector<u8>& buffer, u32 width, u32 height, u16 samples_per_pixel) {
    TIFF* tiff = TIFFOpen(filename, "w");
    if (tiff == nullptr) {
        cerr << "Could not open TIFF file for writing!" << endl;
        return;
    }

    TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);
    TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);
    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 1);  // Grayscale image will have 1 channel
    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);  // 8 bits per pixel for grayscale
    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);  // Grayscale, no RGB

    for (u32 row = 0; row < height; row++) {
        TIFFWriteScanline(tiff, const_cast<u8*>(&buffer[row * width]), row);
    }

    TIFFClose(tiff);
}

int main() {
    const char* inputFile = "board.tif";
    const char* outputFile = "output_decompressed.tif";
    const char* compressedFile = "output_compressed.tif";

    u32 width, height;
    u16 samples_per_pixel;
    double sigma = 1.0;
    vector<u8> buffer;

    // Step 1: Read the TIFF image
    readTiffImage(inputFile, buffer, width, height, samples_per_pixel);

    // Step 2: Apply wavelet compression (simplified)
    waveletTransform(buffer, width, height);

    // Step 3: Write the compressed image to a new TIFF file
    writeTiffImage(compressedFile, buffer, width, height, samples_per_pixel);

    // Step 4: Inverse Wavelet Transform
    // Convert the buffer to double type for the inverse transform
    vector<double> buff_double(buffer.begin(), buffer.end());

    // Perform the inverse transform
    inverseMexicanHatTransform(buff_double, width, height, sigma);

    // Step 5: Convert the reconstructed data back to u8
    vector<u8> reconstructedImage;
    convertToUint8(buff_double, reconstructedImage, width, height);

    // Step 6: Write the decompressed image to a new TIFF file
    writeTiffImage(outputFile, reconstructedImage, width, height, samples_per_pixel);

    cout << "Reconstructed image saved as " << outputFile << endl;
    cout << "Wavelet compression and decompression completed!" << endl;

    return 0;
}
